#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Mon May 23 04:23:05 2022.Isolated pixel detection - a highly specialised application.@author: Nassir Mohammad"""# %%##############################           Setup############################## %% import image handlingfrom point_detection.functions import detect_isolated_pointsimport cv2from matplotlib import pyplot as pltfrom PIL import Imageimport numpy as np# %% set parameterskernel_size = 3binary_image_flag = False# %%##############################       Read Images############################## %% path to imagesdata_path = ("/Users/nassirmohammad/projects/computer_vision/"             "percept_detection/point_line_edge_detection/data/")# %% write to disk for conversion# v2.imwrite("/Users/nassirmohammad/projects/computer_vision/point_line_edge_detection/point_line_edge_detection/data/turbine_blade_black_dot.png", img)# %% specify the greyscale images to input# grey scale images# img_name = "square_shades.png"# img_name = "camera_man.png"# img_name = "turbine_blade_black_dot.tif"# %% # img_name: square_shades.pngimg_name = "square_shades.png"img1 = data_path + img_nameim = Image.open(img1).convert('L')img = np.array(im)# add the isolated pixelsimg[200][100] = 255img[75][150] = 255img[300][100] = 255img[300][350] = 20img[150][150] = 150img[100][120] = 90img[250][350] = 0# show figurefig = plt.figure(figsize=(20, 8))ax1 = fig.add_subplot(111)ax1.imshow(img, cmap='gray')plt.show()# as the image is not natural and not noisy, use binary detectionbinary_image_flag = True# %%##############################       Neural Network############################## %% detect isolated pixels using neural networkif binary_image_flag is True:    input_image = imgelse:    # blur the image, often said to be a process in vision before derivatives    input_image = cv2.GaussianBlur(img, (5, 5), 0)filtered_image, filtered_response = \    detect_isolated_points(input_image,                           excite_num=1,                           inhib_sum_num=0,                           kernel_size=kernel_size)print("Number of isolated pixels located by net is: {}"      .format(np.sum(filtered_response)))# %% show only anomaly response pixelsn = img.shape[0]m = img.shape[1]new_image = np.array(filtered_response)new_image = new_image.reshape(n-kernel_size+1, m-kernel_size+1)# map the [0,1] image to [0,255]new_image = Image.fromarray((new_image * 255).astype(np.uint8))fig = plt.figure(figsize=(20, 8))plt.gray()ax1 = fig.add_subplot(121)ax2 = fig.add_subplot(122)ax1.imshow(img)ax2.imshow(new_image)plt.show()# %% show filtered imagen = img.shape[0]m = img.shape[1]new_image = np.array(filtered_image)new_image = \    new_image.reshape(n-kernel_size+1, m-kernel_size+1).astype(np.uint8)# image is already binary# new_image = Image.fromarray((new_image * 255).astype(np.uint8))fig = plt.figure(figsize=(20, 8))plt.gray()ax1 = fig.add_subplot(121)ax2 = fig.add_subplot(122)ax1.imshow(img)ax2.imshow(new_image)plt.show()# %%##############################   Image Derivatives############################## %% Apply Laplace function (cv2.Laplacian implementation appears to be using# wrong kernel)kernel = np.array([[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]])# ddepth = cv2.CV_16Sdst = cv2.filter2D(img, ddepth=cv2.CV_64F, kernel=kernel)# dst = cv2.Laplacian(img, ddepth, ksize=3)# converting back to uint8abs_dst = np.abs(dst)  # cv2.convertScaleAbs(dst)# find highest pixel value in image and take % of itthreshold = int(0.9 * np.max(abs_dst))output = np.where(abs_dst > threshold, 1, 0)# output = np.where(abs_dst == 2040, 1, 0)print("Number of isolated pixels located by Laplacian is: {}"      .format(np.sum(output)))fig = plt.figure(figsize=(20, 8))plt.gray()ax1 = fig.add_subplot(121)ax2 = fig.add_subplot(122)ax1.imshow(abs_dst)ax2.imshow(output)plt.show()# highly dependent upon the thrshold value.Even then gives false postiives.# %%##############################   Template Matching############################## Direct application of hit or miss transform as template matching does not# give good results, nor is it obvious what the function is carrying out# due to the unexpected output result. This approach will not be continued# since in general the idea is to match exactly a relation in a receptive field# and there will be too many such relations to match using exact templates.# %% hit and miss transform for central white pixel only# input_image = cv2.threshold(img, 254, 255, cv2.THRESH_BINARY)[1]# a test image for understanding hit or miss on grey scale image# img = np.array([[0,0,0,0], [0,0,255,0],[0,0,0,0]], dtype='uint8')input_image = imgkernel = np.array([[-1, -1, -1],                   [-1,  1, -1],                   [-1, -1, -1]], dtype="int")single_pixels = cv2.morphologyEx(input_image, cv2.MORPH_HITMISS, kernel)# single_pixels_inv = cv2.bitwise_not(single_pixels)# hm = cv2.bitwise_and(input_image, input_image, mask=single_pixels_inv)# show figurefig = plt.figure(figsize=(20, 8))ax1 = fig.add_subplot(111)ax1.imshow(img, cmap='gray')plt.show()# show figurefig = plt.figure(figsize=(20, 8))ax1 = fig.add_subplot(111)ax1.imshow(single_pixels, cmap='gray')plt.show()# %% hit and miss transform for central black pixel only# input_image = cv2.threshold(img, 254, 255, cv2.THRESH_BINARY)[1]input_image = imgkernel = np.array([[1, 1, 1],                    [1, -1, 1],                    [1, 1, 1]], dtype="int")single_pixels = cv2.morphologyEx(input_image, cv2.MORPH_HITMISS, kernel)single_pixels_inv = cv2.bitwise_not(single_pixels)hm = cv2.bitwise_and(input_image, input_image, mask=single_pixels_inv)# show figurefig = plt.figure(figsize=(20, 8))ax1 = fig.add_subplot(111)ax1.imshow(single_pixels_inv, cmap='gray')plt.show()