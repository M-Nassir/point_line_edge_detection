#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Mon May 23 04:23:05 2022.Isolated pixel detection - a highly specialised application.@author: Nassir Mohammad"""# %%##############################           Setup############################## %% import image handlingfrom point_detection.functions import detect_isolated_points, display_image_plus_responsesimport cv2from matplotlib import pyplot as pltfrom PIL import Imageimport numpy as npimport matplotlib.pyplot as pltimport matplotlib.image as mpimgfrom skimage import io# %% set parameterskernel_size = 3binary_image_flag = False# %%##############################       Read Images############################## %% setupimage_save_switch = False# %% path to imagesdata_path = ("../../data/")# %%with open('../../paths.txt') as f:    image_save_path = f.readline()    image_save_path = image_save_path[:-1]    print(image_save_path)# %% write to disk for conversion# v2.imwrite("/Users/nassirmohammad/projects/computer_vision/point_line_edge_detection/point_line_edge_detection/data/turbine_blade_black_dot.png", img)# %% airbus real image with defectsimg_name = "ab1.png"img_path = data_path + img_name# read and keep image as uint16, as conversion to uint8 drops detailsimg = io.imread(img_path, as_gray=True)# unit8_img = cv2.convertScaleAbs(img)# img = mpimg.imread(img)# img = rgb2gray(img)cropped_img = img[200:600, 400:800]cv2.imwrite(data_path + "ab1_cropped.png", cropped_img)# cropped_image = Image.fromarray(img)# cropped_image.save(data_path + "ab1_cropped.png")imgplot = plt.imshow(cropped_img)plt.show()# %% read cropped airbus imageimg_name = "ab1_cropped.png"img_path = data_path + img_nameimg = io.imread(img_path, as_gray=True)# add the isolated pixelsimg[200][100] = 240img[75][150] = 65535img[300][100] = 65535img[300][350] = 20img[150][150] = 30000img[100][120] = 30000img[250][350] = 0imgplot = plt.imshow(img)plt.show()binary_image_flag = False# %% turbine_blade_black_dotimg_name = "turbine_blade_black_dot.png"img1 = data_path + img_nameim = Image.open(img1).convert('L')img = np.array(im)# show figurefig = plt.figure(figsize=(20, 8))ax1 = fig.add_subplot(111)ax1.imshow(img, cmap='gray')plt.show()binary_image_flag = False# %% "camera_man.png" (not good example because it is a natural image)# img_name = "camera_man.png"# img1 = data_path + img_name# im = Image.open(img1).convert('L')# img = np.array(im)# # add the isolated pixels# img[200][100] = 255# img[75][150] = 255# img[200][140] = 50# img[250][150] = 255# img[150][150] = 150# img[100][120] = 90# # show figure# fig = plt.figure(figsize=(20, 8))# ax1 = fig.add_subplot(111)# ax1.imshow(img, cmap='gray')# plt.show()# binary_image_flag = True# %%##############################       Neural Network############################## Here are some specific guidelines for different types of images:# Natural images (e.g., landscapes, portraits): 5x5 or 7x7 kernel size# Medical images (e.g., MRI, CT scans): 3x3 or 5x5 kernel size (to preserve fine details)# Textured images (e.g., fabrics, wood): 7x7 or 9x9 kernel size (to remove texture noise)# Low-light images: 3x3 or 5x5 kernel size (to reduce noise amplification)# %% detect isolated pixels using neural networkif binary_image_flag is True:    input_image = imgelse:    # blur the image, often said to be a process in vision before derivatives    input_image = cv2.GaussianBlur(img, (5, 5), 0)imgplot_blurred = plt.imshow(input_image)plt.show()filtered_image, filtered_response = \    detect_isolated_points(input_image,                           excite_num=1,                           inhib_sum_num=0,                           kernel_size=kernel_size)print("Number of isolated pixels located by net is: {}"      .format(np.sum(filtered_response)))# Display anomaly response pixelsdisplay_image_plus_responses(input_image, filtered_response, "Anomaly Response Pixels", kernel_size)# Display filtered imagedisplay_image_plus_responses(input_image, filtered_image, "Filtered Image", kernel_size)# %%##############################   Image Derivatives############################## %% Apply Laplace functionkernel = np.array([[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]])dst = cv2.filter2D(img, ddepth=cv2.CV_64F, kernel=kernel)# converting back to uint8abs_dst = np.abs(dst)  # cv2.convertScaleAbs(dst)# find highest pixel value in image and take % of itthreshold = int(0.9 * np.max(abs_dst))output = np.where(abs_dst > threshold, 1, 0)# output = np.where(abs_dst == 2040, 1, 0)print("Number of isolated pixels located by Laplacian is: {}"      .format(np.sum(output)))fig = plt.figure(figsize=(20, 8))plt.gray()ax1 = fig.add_subplot(121)ax2 = fig.add_subplot(122)ax1.imshow(abs_dst)ax2.imshow(output)plt.show()