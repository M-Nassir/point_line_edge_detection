#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Mon May 23 04:23:05 2022.Isolated pixel detection - a highly specialised application.@author: Nassir MohammadThis script will process some realworld isolated pixel examples. It willalso smooth an image if desired as some images can be quite noisy leadingto false positives. 3*3 or 5*5 kernels are good enough generally for suchimagery. An example is created to demonstrate the application of transforming a problemwhere nodes might be spatially similar in terms of feature values, but theremaybe a single rogue node or malfunctioning node. This is represented as animage from such network or spatial data, then the isolated pixels are detected.Note that this application is different from that of filtering and smoothing animage such as removing impulse noise because in that case we are notnecessarily looking to find the location of the actual points."""# TODO: fix what filtered_image returned is# TODO: check what functions are doing that are called and tidy make them efficient# %%##############################           Setup############################## importsfrom point_detection.functions import detect_isolated_pointsfrom point_detection.functions import display_image_plus_responsesimport cv2from matplotlib import pyplot as pltfrom PIL import Image, ImageFilterfrom noise import snoise2import numpy as npfrom pathlib import Pathfrom IPython.display import display# set parameterskernel_size = 3binary_image_flag = Falseimage_save_switch = False# %%##############################       Read Images############################## %% path to images **** Ensure current file selected is the current script *****# otherwise the relative path will be incorrectdata_path = Path("../../data/")# Read the first line from the paths.txt fileimage_save_path = Path('../../paths.txt').read_text().splitlines()[0].strip()print(image_save_path)# %% Process the Airbus defect image images as required# airbus real image with defectsimg_name = "ab1.png"img_path = data_path / img_nameimg_original = Image.open(img_path).convert('L')img = np.array(img_original)cropped_img = img[200:600, 400:800]# Save cropped imagecv2.imwrite(str(data_path / "ab1_cropped.png"), cropped_img)# convert back to image for showcropped_PIL_image = Image.fromarray(cropped_img)cropped_PIL_image.show()# %% crop the suspicious_nodes image (isolated pixels are actually more than# single pixels) - not required# img_name = "suspicious_nodes.png"# img_path = data_path + img_name# # read and keep image as uint16, as conversion to uint8 drops details# img = io.imread(img_path, as_gray=True)# # Extract the pixel values from x=270 onward and y=150 onward# cropped_img = img[150:, 270:]# cropped_img[10][50] = 0# # Save the pixel values as a new image (if needed)# bottom_right_image = Image.fromarray(cropped_img)# # Save the image as a new file# bottom_right_image.save('bottom_right_corner.png')# # If you want to display it# # bottom_right_image.show()# # Display the cropped image using matplotlib# plt.imshow(cropped_img, cmap='gray')# plt.title('Cropped Image')# plt.show()# %% Create smooth gradient images and add isolated pixels representing# anomalous nodes# Image dimensionswidth, height = 128, 128# Parameters for Perlin noisescale = 25.0  # Increase scale for smoother regionsoctaves = 6    # Number of octavespersistence = 0.5  # Amplitude of the noiselacunarity = 2.0   # Frequency of the noise# Generate Perlin noisedef generate_noise(width, height, scale, octaves, persistence, lacunarity):    noise_data = np.zeros((height, width))    for y in range(height):        for x in range(width):            noise_value = snoise2(x / scale,                                  y / scale,                                  octaves=octaves,                                  persistence=persistence,                                  lacunarity=lacunarity,                                  repeatx=1024,                                  repeaty=1024,                                  base=42)            noise_data[y, x] = noise_value    return noise_data# Create noise imagenoise_data = generate_noise(width, height, scale, octaves, persistence, lacunarity)# Normalize the data to 0-255noise_data = (noise_data - noise_data.min()) / (noise_data.max() - noise_data.min()) * 255image_data = np.uint8(noise_data)# Convert to PIL Imageimage = Image.fromarray(image_data, mode='L')# Apply Gaussian blur to smooth the regionsimage = image.filter(ImageFilter.GaussianBlur(radius=2))# Convert image back to numpy array for manipulationout_img = np.array(image)# Add 10 isolated pixels with unusually low or high valuesnum_isolated_pixels = 10for _ in range(num_isolated_pixels):    x, y = np.random.randint(0, width), np.random.randint(0, height)    # Get the current pixel value    current_value = out_img[y, x]    # Determine the range for unusually low or high values    if np.random.rand() > 0.5:        # Choose an unusually high value        extreme_value = current_value + np.random.uniform(20, 60)    else:        # Choose an unusually low value        extreme_value = current_value - np.random.uniform(20, 60)    # Ensure the extreme value is within 0-255    extreme_value = np.clip(extreme_value, 0, 255)    # Assign the extreme value to the pixel    out_img[y, x] = extreme_value# Convert back to PIL Imagefinal_image = Image.fromarray(out_img, mode='L')# Display the imagefinal_image.show()# Write the image to diskfinal_image.save(data_path /'spatial_anomaly_nodes.png')# Image.open(data_path /'spatial_anomaly_nodes.png').convert('L')# %% specify the greyscale images to inputimage_options = [    'spatial_anomaly_nodes.png',    "turbine_blade_black_dot.png",    'camera_man.png',    # rest not required, originally used for development and testing    "ab1.png",                           # 0    "ab1_cropped.png",                   # 1    "xd3ke.png",                         # 3    "spatial_anomalous_nodes.png",       # 4    'test13.png',                        # 6]# Select the desired image by its index (0-based)selected_image_index = 0img_name = image_options[selected_image_index]print(f'Selected image: {img_name}')img_path = data_path / img_nameimg_original = Image.open(data_path / 'spatial_anomaly_nodes.png').convert('L')img_array = np.array(img_original)print(f'Size of image: {img_original.size}')display(img_original)# %% process images as requiredif img_name =='ab1_cropped.png':    # read cropped airbus image and check, add isolated pixels if required    # ensure image values are all between {0, 255}    # add the isolated pixels    img_array[200][100] = 240    img_array[75][150] = 255    img_array[300][100] = 255    img_array[300][350] = 20    img_array[150][150] = 255    img_array[100][120] = 255    img_array[250][350] = 0    print(f'Number of isolated pixels added: 7')    binary_image_flag = Falseelif img_name == 'turbine_blade_black_dot.png':    binary_image_flag = Falseelif img_name == "camera_man.png":    # "camera_man.png" (not good example because it is a natural image)    # add the isolated pixels    img_array[200][100] = 255    img_array[75][150] = 255    img_array[200][140] = 50    img_array[250][150] = 255    img_array[150][150] = 150    img_array[100][120] = 90    print(f'Number of isolated pixels added: 6')    binary_image_flag = Falseelif img_name == "spatial_anomaly_nodes.png":    binary_image_flag = Trueelif img_name == "test13.png":    binary_image_flag = Falseimg_PIL = Image.fromarray(img_array)display(img_PIL)# %%##############################       Neural Network############################## Here are some specific guidelines for different types of images:# Natural images (e.g., landscapes, portraits): 5x5 or 7x7 kernel size# Medical images (e.g., MRI, CT scans): 3x3 or 5x5 kernel size (to preserve fine details)# Textured images (e.g., fabrics, wood): 7x7 or 9x9 kernel size (to remove texture noise)# Low-light images: 3x3 or 5x5 kernel size (to reduce noise amplification)# %% detect isolated pixels using neural networkif binary_image_flag is True:    input_image = img_arrayelse:    # blur the image, often said to be a process in vision before derivatives    input_image = cv2.GaussianBlur(img_array, (3, 3), 0)    fig, axes = plt.subplots(1, 2, figsize=(10, 5))    for ax, img_array, title in zip(axes, [img_array, input_image], ['Original Image',                                                         "Gaussiann blurred image: 5*5"]):        ax.imshow(img_array, cmap='gray')        ax.set_title(title)        ax.axis('off')    plt.show()filtered_image, filtered_response = \    detect_isolated_points(input_image,                           excite_num=1,                           inhib_sum_num=0,                           kernel_size=kernel_size)print("Number of isolated pixels located by net is: {}"      .format(np.sum(filtered_response)))# Display anomaly response pixelsdisplay_image_plus_responses(input_image, filtered_response, "Anomaly Response Pixels", kernel_size)# Display filtered imagedisplay_image_plus_responses(input_image, filtered_image, "Filtered Image", kernel_size)# %%##############################   Image Derivatives############################## %% detect isolated pixels using neural networkif binary_image_flag is True:    input_image = img_arrayelse:    # blur the image, often said to be a process in vision before derivatives    input_image = cv2.GaussianBlur(img_array, (5, 5), 0)# Apply Laplace functionkernel = np.array([[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]])dst = cv2.filter2D(input_image, ddepth=cv2.CV_64F, kernel=kernel)# converting with absolute values as responses can be negativeabs_dst = np.abs(dst)# find highest pixel value in image and take % of itthreshold = int(0.9 * np.max(abs_dst))output_img_array = np.where(abs_dst > threshold, 1, 0)print("Number of isolated pixels located by Laplacian is: {}"      .format(np.sum(output_img_array)))# Create a figure with three subplotsfig = plt.figure(figsize=(20, 8))plt.gray()# Display the input imageax1 = fig.add_subplot(131)ax1.imshow(input_image)ax1.set_title('Input Image')ax1.axis('off')# Display the Laplacian outputax2 = fig.add_subplot(132)ax2.imshow(abs_dst)ax2.set_title('Laplacian Output')ax2.axis('off')# Display the thresholded outputax3 = fig.add_subplot(133)ax3.imshow(output_img_array)ax3.set_title('Thresholded Output')ax3.axis('off')plt.show()