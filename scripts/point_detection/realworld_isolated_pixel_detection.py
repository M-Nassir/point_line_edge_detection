#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Mon May 23 04:23:05 2022.Isolated pixel detection - a highly specialised application.@author: Nassir Mohammad"""# TODO: tidy the code up# TODO: fix what filtered_image returned is# TODO: check what functions are doing that are called and tidy make them efficient# %%##############################           Setup############################## importsfrom point_detection.functions import detect_isolated_pointsfrom point_detection.functions import display_image_plus_responsesimport cv2from matplotlib import pyplot as pltfrom PIL import Image, ImageFilterfrom noise import snoise2import numpy as npfrom pathlib import Path# set parameterskernel_size = 3binary_image_flag = Falseimage_save_switch = False# %% Functionsdef show_plt_image(img_path):    try:        img = Image.open(img_path).convert('L')        img.show()    except Exception as e:        raise ValueError("Failed to display image").with_traceback(e.__traceback__)# %%##############################       Read Images############################## %% path to imagesdata_path = Path("../../data/")# Read the first line from the paths.txt fileimage_save_path = Path('../../paths.txt').read_text().splitlines()[0].strip()print(image_save_path)# %% Process the images as required to create images# airbus real image with defectsimg_name = "ab1.png"img_path = data_path / img_name# read and keep image as uint16, as conversion to uint8 drops detailsimg_original =  Image.open(img_path).convert('L')img = np.array(img_original)cropped_img = img[200:600, 400:800]# Save cropped imagecv2.imwrite(str(data_path / "ab1_cropped.png"), cropped_img)cropped_PIL_image = Image.fromarray(cropped_img)cropped_PIL_image.show()# %% crop the suspicious_nodes image (isolated pixels are actually more than# single pixels) - not required# img_name = "suspicious_nodes.png"# img_path = data_path + img_name# # read and keep image as uint16, as conversion to uint8 drops details# img = io.imread(img_path, as_gray=True)# # Extract the pixel values from x=270 onward and y=150 onward# cropped_img = img[150:, 270:]# cropped_img[10][50] = 0# # Save the pixel values as a new image (if needed)# bottom_right_image = Image.fromarray(cropped_img)# # Save the image as a new file# bottom_right_image.save('bottom_right_corner.png')# # If you want to display it# # bottom_right_image.show()# # Display the cropped image using matplotlib# plt.imshow(cropped_img, cmap='gray')# plt.title('Cropped Image')# plt.show()# %% Create smooth gradient images and add isolated pixels representing# anomalous nodes# Image dimensionswidth, height = 50, 50# Parameters for Perlin noisescale = 25.0  # Increase scale for smoother regionsoctaves = 6    # Number of octavespersistence = 0.5  # Amplitude of the noiselacunarity = 2.0   # Frequency of the noise# Generate Perlin noisedef generate_noise(width, height, scale, octaves, persistence, lacunarity):    noise_data = np.zeros((height, width))    for y in range(height):        for x in range(width):            noise_value = snoise2(x / scale,                                  y / scale,                                  octaves=octaves,                                  persistence=persistence,                                  lacunarity=lacunarity,                                  repeatx=1024,                                  repeaty=1024,                                  base=42)            noise_data[y, x] = noise_value    return noise_data# Create noise imagenoise_data = generate_noise(width, height, scale, octaves, persistence, lacunarity)# Normalize the data to 0-255noise_data = (noise_data - noise_data.min()) / (noise_data.max() - noise_data.min()) * 255image_data = np.uint8(noise_data)# Convert to PIL Imageimage = Image.fromarray(image_data, mode='L')# Apply Gaussian blur to smooth the regionsimage = image.filter(ImageFilter.GaussianBlur(radius=2))# Convert image back to numpy array for manipulationout_img = np.array(image)# Add 10 isolated pixels with unusually low or high valuesnum_isolated_pixels = 10for _ in range(num_isolated_pixels):    x, y = np.random.randint(0, width), np.random.randint(0, height)    # Get the current pixel value    current_value = out_img[y, x]    # Determine the range for unusually low or high values    if np.random.rand() > 0.5:        # Choose an unusually high value        extreme_value = current_value + np.random.uniform(20, 60)    else:        # Choose an unusually low value        extreme_value = current_value - np.random.uniform(20, 60)    # Ensure the extreme value is within 0-255    extreme_value = np.clip(extreme_value, 0, 255)    # Assign the extreme value to the pixel    out_img[y, x] = extreme_value# Convert back to PIL Imagefinal_image = Image.fromarray(out_img, mode='L')# Display the imagefinal_image.show()# %% specify the greyscale images to inputimage_options = [    "ab1.png",                           # 0    "ab1_cropped.png",                   # 1    "turbine_blade_black_dot.png",       # 2    "xd3ke.png",                         # 3    "spatial_anomalous_nodes.png",       # 4    'camera_man.png',                    # 5    'test13.png',                        # 6]# Select the desired image by its index (0-based)selected_image_index = 4img_name = image_options[selected_image_index]print(f'Selected image: {img_name}')img_path = data_path + img_nameimg = Image.open(img_path).convert('L')img = np.array(img)# Display the image using matplotlibplt.imshow(img, cmap='gray')plt.axis('off')  # Hide the axes for better visualizationplt.show()# %%if img_name =='ab1_cropped.png':    # read cropped airbus image and check, add isolated pixels if required    # ensure image values are all between {0, 255}    # add the isolated pixels    img[200][100] = 240    img[75][150] = 255    img[300][100] = 255    img[300][350] = 20    img[150][150] = 255    img[100][120] = 255    img[250][350] = 0    show_plt_image(img)    binary_image_flag = Falseelif img_name == 'turbine_blade_black_dot.png':    show_plt_image(img)    binary_image_flag = Falseelif img_name == "camera_man.png":    # "camera_man.png" (not good example because it is a natural image)    # add the isolated pixels    img[200][100] = 255    img[75][150] = 255    img[200][140] = 50    img[250][150] = 255    img[150][150] = 150    img[100][120] = 90    print(f'Number of isolated pixels added: 6')    # show figure    show_plt_image(img)    binary_image_flag = Falseelif img_name == "suspicious_nodes.png":    show_plt_image(img)    binary_image_flag = Trueelif img_name == "test13.png":    show_plt_image(img)    binary_image_flag = True# %%##############################       Neural Network############################## Here are some specific guidelines for different types of images:# Natural images (e.g., landscapes, portraits): 5x5 or 7x7 kernel size# Medical images (e.g., MRI, CT scans): 3x3 or 5x5 kernel size (to preserve fine details)# Textured images (e.g., fabrics, wood): 7x7 or 9x9 kernel size (to remove texture noise)# Low-light images: 3x3 or 5x5 kernel size (to reduce noise amplification)# %% detect isolated pixels using neural networkif binary_image_flag is True:    input_image = imgelse:    # blur the image, often said to be a process in vision before derivatives    input_image = cv2.GaussianBlur(img, (5, 5), 0)    fig, axes = plt.subplots(1, 2, figsize=(10, 5))    for ax, img, title in zip(axes, [img, input_image], ['Original Image',                                                         "Gaussiann blurred image: 5*5"]):        ax.imshow(img, cmap='gray')        ax.set_title(title)        ax.axis('off')    plt.show()filtered_image, filtered_response = \    detect_isolated_points(input_image,                           excite_num=1,                           inhib_sum_num=0,                           kernel_size=kernel_size)print("Number of isolated pixels located by net is: {}"      .format(np.sum(filtered_response)))# Display anomaly response pixelsdisplay_image_plus_responses(input_image, filtered_response, "Anomaly Response Pixels", kernel_size)# Display filtered imagedisplay_image_plus_responses(input_image, filtered_image, "Filtered Image", kernel_size)# %%##############################   Image Derivatives############################## %% detect isolated pixels using neural networkif binary_image_flag is True:    input_image = imgelse:    # blur the image, often said to be a process in vision before derivatives    input_image = cv2.GaussianBlur(img, (5, 5), 0)# Apply Laplace functionkernel = np.array([[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]])dst = cv2.filter2D(input_image, ddepth=cv2.CV_64F, kernel=kernel)# converting back to uint8abs_dst = np.abs(dst)  # cv2.convertScaleAbs(dst)# find highest pixel value in image and take % of itthreshold = int(0.9 * np.max(abs_dst))output = np.where(abs_dst > threshold, 1, 0)# output = np.where(abs_dst == 2040, 1, 0)print("Number of isolated pixels located by Laplacian is: {}"      .format(np.sum(output)))fig = plt.figure(figsize=(20, 8))plt.gray()ax1 = fig.add_subplot(121)ax2 = fig.add_subplot(122)ax1.imshow(abs_dst)ax2.imshow(output)plt.show()