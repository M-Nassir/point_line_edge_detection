#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Mon May 23 04:23:05 2022.Isolated pixel detection - a highly specialised application.@author: Nassir Mohammad"""# %%##############################           Setup############################## %% import image handlingfrom point_detection.functions import detect_isolated_pointsimport cv2from matplotlib import pyplot as pltfrom PIL import Imageimport numpy as np# %% set parameterskernel_size = 3binary_image_flag = False# %%##############################       Read Images############################## %% setupimage_save_switch = True# %% path to imagesdata_path = ("../../data/")# %%with open('../../paths.txt') as f:    image_save_path = f.readline()    image_save_path = image_save_path[:-1]    print(image_save_path)# %% write to disk for conversion# v2.imwrite("/Users/nassirmohammad/projects/computer_vision/point_line_edge_detection/point_line_edge_detection/data/turbine_blade_black_dot.png", img)# %% turbine_blade_black_dotimg_name = "turbine_blade_black_dot.png"img1 = data_path + img_nameim = Image.open(img1).convert('L')img = np.array(im)# show figurefig = plt.figure(figsize=(20, 8))ax1 = fig.add_subplot(111)ax1.imshow(img, cmap='gray')plt.show()binary_image_flag = False# %% "camera_man.png" (not good example because it is a natural image)img_name = "camera_man.png"img1 = data_path + img_nameim = Image.open(img1).convert('L')img = np.array(im)# add the isolated pixelsimg[200][100] = 255img[75][150] = 255img[200][140] = 50img[250][150] = 255img[150][150] = 150img[100][120] = 90# show figurefig = plt.figure(figsize=(20, 8))ax1 = fig.add_subplot(111)ax1.imshow(img, cmap='gray')plt.show()binary_image_flag = True# %%##############################       Neural Network############################## %% detect isolated pixels using neural networkif binary_image_flag is True:    input_image = imgelse:    # blur the image, often said to be a process in vision before derivatives    input_image = cv2.GaussianBlur(img, (5, 5), 0)filtered_image, filtered_response = \    detect_isolated_points(input_image,                           excite_num=1,                           inhib_sum_num=0,                           kernel_size=kernel_size)print("Number of isolated pixels located by net is: {}"      .format(np.sum(filtered_response)))# %% show only anomaly response pixelsn = img.shape[0]m = img.shape[1]new_image = np.array(filtered_response)new_image = new_image.reshape(n-kernel_size+1, m-kernel_size+1)# map the [0,1] image to [0,255]new_image = Image.fromarray((new_image * 255).astype(np.uint8))fig = plt.figure(figsize=(20, 8))plt.gray()ax1 = fig.add_subplot(121)ax2 = fig.add_subplot(122)ax1.imshow(img)ax2.imshow(new_image)plt.show()# %% show filtered imagen = img.shape[0]m = img.shape[1]new_image = np.array(filtered_image)new_image = \    new_image.reshape(n-kernel_size+1, m-kernel_size+1).astype(np.uint8)# image is already binary# new_image = Image.fromarray((new_image * 255).astype(np.uint8))fig = plt.figure(figsize=(20, 8))plt.gray()ax1 = fig.add_subplot(121)ax2 = fig.add_subplot(122)ax1.imshow(img)ax2.imshow(new_image)plt.show()# %%##############################   Image Derivatives############################## %% Apply Laplace functionkernel = np.array([[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]])dst = cv2.filter2D(img, ddepth=cv2.CV_64F, kernel=kernel)# converting back to uint8abs_dst = np.abs(dst)  # cv2.convertScaleAbs(dst)# find highest pixel value in image and take % of itthreshold = int(0.9 * np.max(abs_dst))output = np.where(abs_dst > threshold, 1, 0)# output = np.where(abs_dst == 2040, 1, 0)print("Number of isolated pixels located by Laplacian is: {}"      .format(np.sum(output)))fig = plt.figure(figsize=(20, 8))plt.gray()ax1 = fig.add_subplot(121)ax2 = fig.add_subplot(122)ax1.imshow(abs_dst)ax2.imshow(output)plt.show()